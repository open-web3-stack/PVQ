# PVQ Primitives

<!-- generated by polka.codes -->

Core primitive types and utilities for the PVQ (PolkaVM Query) ecosystem. This crate provides fundamental data structures, error types, and serialization utilities that ensure interoperability across all PVQ components.

## Overview

PVQ Primitives serves as the foundational layer for all PVQ components, providing standardized types and utilities that enable seamless communication between guest programs, extensions, executors, and runtime APIs.

## Features

- ğŸ“¦ **Core Data Types**: Fundamental types used across the PVQ ecosystem
- ğŸ”„ **Serialization Support**: Efficient encoding/decoding with multiple formats
- âŒ **Error Handling**: Comprehensive error types with detailed context
- ğŸ”— **Interoperability**: Consistent types across all PVQ components
- ğŸ“ **Size Optimization**: Compact representations for performance
- ğŸ›¡ï¸ **Type Safety**: Strong typing to prevent runtime errors

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PVQ Primitives                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Core Types    â”‚  â”‚   Error Types   â”‚  â”‚  Utilities   â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚                 â”‚  â”‚              â”‚ â”‚
â”‚  â”‚ â”œâ”€ PvqResult    â”‚  â”‚ â”œâ”€ PvqError     â”‚  â”‚ â”œâ”€ Codec     â”‚ â”‚
â”‚  â”‚ â”œâ”€ PvqResponse  â”‚  â”‚ â”œâ”€ ErrorCode    â”‚  â”‚ â”œâ”€ Hashing   â”‚ â”‚
â”‚  â”‚ â”œâ”€ QueryData    â”‚  â”‚ â”œâ”€ ErrorContext â”‚  â”‚ â”œâ”€ Validationâ”‚ â”‚
â”‚  â”‚ â”œâ”€ Metadata     â”‚  â”‚ â””â”€ ErrorChain   â”‚  â”‚ â””â”€ Constants â”‚ â”‚
â”‚  â”‚ â””â”€ Context      â”‚  â”‚                 â”‚  â”‚              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Core Types

### PvqResult<T>

The standard result type for PVQ operations:

```rust
use pvq_primitives::{PvqResult, PvqError};

pub type PvqResult<T> = Result<T, PvqError>;

// Usage example
fn example_function() -> PvqResult<String> {
    Ok("Success".to_string())
}

// Error handling
match example_function() {
    Ok(value) => println!("Success: {}", value),
    Err(error) => println!("Error: {}", error),
}
```

### PvqResponse

Standard response wrapper for query results:

```rust
use pvq_primitives::{PvqResponse, QueryMetadata};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct PvqResponse<T> {
    pub data: T,
    pub metadata: QueryMetadata,
    pub success: bool,
}

impl<T> PvqResponse<T> {
    pub fn success(data: T) -> Self {
        Self {
            data,
            metadata: QueryMetadata::default(),
            success: true,
        }
    }
    
    pub fn error(data: T, error: String) -> Self {
        Self {
            data,
            metadata: QueryMetadata::with_error(error),
            success: false,
        }
    }
}

// Usage in guest programs
#[pvq_program::program]
fn my_query() -> PvqResponse<String> {
    PvqResponse::success("Query completed".to_string())
}
```

### QueryData

Standardized input/output data format:

```rust
use pvq_primitives::QueryData;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct QueryData<T> {
    pub payload: T,
    pub version: u32,
    pub timestamp: u64,
}

impl<T> QueryData<T> {
    pub fn new(payload: T) -> Self {
        Self {
            payload,
            version: 1,
            timestamp: current_timestamp(),
        }
    }
}
```

## Error Handling

### PvqError

Comprehensive error type covering all failure scenarios:

```rust
use pvq_primitives::PvqError;
use thiserror::Error;

#[derive(Error, Debug, Clone, PartialEq)]
pub enum PvqError {
    #[error("Program execution failed: {message}")]
    ExecutionError { 
        message: String,
        code: u32,
    },
    
    #[error("Extension call failed: {extension}.{function}")]
    ExtensionError {
        extension: String,
        function: String,
        reason: String,
    },
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Permission denied: {operation}")]
    PermissionDenied { 
        operation: String 
    },
    
    #[error("Resource limit exceeded: {resource}")]
    ResourceLimitExceeded {
        resource: String,
        limit: u64,
        requested: u64,
    },
    
    #[error("Invalid input: {field}")]
    InvalidInput { 
        field: String,
        expected: String,
        received: String,
    },
    
    #[error("Timeout after {duration_ms}ms")]
    Timeout { 
        duration_ms: u64 
    },
    
    #[error("Internal error: {0}")]
    Internal(String),
}
```

### Error Construction Utilities

Helper functions for creating common errors:

```rust
use pvq_primitives::PvqError;

impl PvqError {
    pub fn execution_failed(message: impl Into<String>) -> Self {
        Self::ExecutionError {
            message: message.into(),
            code: 1001,
        }
    }
    
    pub fn extension_failed(
        extension: impl Into<String>,
        function: impl Into<String>,
        reason: impl Into<String>,
    ) -> Self {
        Self::ExtensionError {
            extension: extension.into(),
            function: function.into(),
            reason: reason.into(),
        }
    }
    
    pub fn invalid_input(
        field: impl Into<String>,
        expected: impl Into<String>,
        received: impl Into<String>,
    ) -> Self {
        Self::InvalidInput {
            field: field.into(),
            expected: expected.into(),
            received: received.into(),
        }
    }
}

// Usage
fn validate_input(value: u32) -> PvqResult<u32> {
    if value == 0 {
        Err(PvqError::invalid_input(
            "value",
            "non-zero number",
            "0"
        ))
    } else {
        Ok(value)
    }
}
```

## Metadata Types

### QueryMetadata

Metadata about query execution:

```rust
use pvq_primitives::QueryMetadata;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct QueryMetadata {
    pub execution_time_ms: u64,
    pub memory_used_bytes: u64,
    pub extension_calls: u32,
    pub block_number: u32,
    pub error_message: Option<String>,
}

impl QueryMetadata {
    pub fn new() -> Self {
        Self {
            execution_time_ms: 0,
            memory_used_bytes: 0,
            extension_calls: 0,
            block_number: 0,
            error_message: None,
        }
    }
    
    pub fn with_error(error: String) -> Self {
        Self {
            error_message: Some(error),
            ..Self::new()
        }
    }
}
```

### ExtensionMetadata

Metadata for extension functions:

```rust
use pvq_primitives::ExtensionMetadata;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ExtensionMetadata {
    pub name: String,
    pub version: String,
    pub description: String,
    pub functions: Vec<FunctionMetadata>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct FunctionMetadata {
    pub name: String,
    pub parameters: Vec<ParameterInfo>,
    pub return_type: TypeInfo,
    pub description: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ParameterInfo {
    pub name: String,
    pub type_info: TypeInfo,
    pub optional: bool,
    pub description: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TypeInfo {
    pub name: String,
    pub size_hint: Option<usize>,
    pub is_collection: bool,
}
```

## Serialization Utilities

### Codec Support

Support for multiple serialization formats:

```rust
use pvq_primitives::codec::{Encode, Decode, Codec};
use serde::{Serialize, Deserialize};

// Types that work with both SCALE and Serde
#[derive(Encode, Decode, Serialize, Deserialize)]
pub struct MyData {
    pub value: u64,
    pub name: String,
}

// Codec utilities
pub fn encode_data<T: Encode>(data: &T) -> Vec<u8> {
    data.encode()
}

pub fn decode_data<T: Decode>(bytes: &[u8]) -> PvqResult<T> {
    T::decode(&mut &bytes[..])
        .map_err(|e| PvqError::SerializationError(e.to_string()))
}

// JSON utilities
pub fn to_json<T: Serialize>(data: &T) -> PvqResult<String> {
    serde_json::to_string(data)
        .map_err(|e| PvqError::SerializationError(e.to_string()))
}

pub fn from_json<T: for<'de> Deserialize<'de>>(json: &str) -> PvqResult<T> {
    serde_json::from_str(json)
        .map_err(|e| PvqError::SerializationError(e.to_string()))
}
```

### Custom Serialization

For performance-critical applications:

```rust
use pvq_primitives::codec::{Encode, Decode, Error};

pub struct CompactData {
    pub numbers: Vec<u32>,
    pub flags: u8,
}

impl Encode for CompactData {
    fn encode(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        
        // Encode length + data
        bytes.extend((self.numbers.len() as u32).to_le_bytes());
        for &num in &self.numbers {
            bytes.extend(num.to_le_bytes());
        }
        bytes.push(self.flags);
        
        bytes
    }
}

impl Decode for CompactData {
    fn decode<I: codec::Input>(input: &mut I) -> Result<Self, Error> {
        let len = u32::decode(input)? as usize;
        let mut numbers = Vec::with_capacity(len);
        
        for _ in 0..len {
            numbers.push(u32::decode(input)?);
        }
        
        let flags = u8::decode(input)?;
        
        Ok(Self { numbers, flags })
    }
}
```

## Constants and Configuration

### System Constants

Common constants used across PVQ:

```rust
use pvq_primitives::constants::*;

// Execution limits
pub const MAX_EXECUTION_TIME_MS: u64 = 30_000;
pub const MAX_MEMORY_BYTES: u64 = 64 * 1024 * 1024; // 64MB
pub const MAX_CALL_DEPTH: u32 = 256;

// Data limits  
pub const MAX_INPUT_SIZE_BYTES: usize = 1024 * 1024; // 1MB
pub const MAX_OUTPUT_SIZE_BYTES: usize = 10 * 1024 * 1024; // 10MB
pub const MAX_EXTENSION_NAME_LENGTH: usize = 64;

// Protocol versions
pub const PVQ_PROTOCOL_VERSION: u32 = 1;
pub const MIN_SUPPORTED_VERSION: u32 = 1;
pub const MAX_SUPPORTED_VERSION: u32 = 1;
```

### Configuration Types

Runtime configuration structures:

```rust
use pvq_primitives::config::*;

#[derive(Debug, Clone)]
pub struct PvqConfig {
    pub max_execution_time_ms: u64,
    pub max_memory_bytes: u64,
    pub max_extensions: u32,
    pub enable_debugging: bool,
    pub permission_model: PermissionModel,
}

impl Default for PvqConfig {
    fn default() -> Self {
        Self {
            max_execution_time_ms: MAX_EXECUTION_TIME_MS,
            max_memory_bytes: MAX_MEMORY_BYTES,
            max_extensions: 32,
            enable_debugging: false,
            permission_model: PermissionModel::Strict,
        }
    }
}

#[derive(Debug, Clone)]
pub enum PermissionModel {
    Open,     // All extensions allowed
    Strict,   // Explicit permission required
    Sandbox,  // Limited core functionality only
}
```

## Validation Utilities

### Input Validation

Common validation functions:

```rust
use pvq_primitives::validation::*;

pub fn validate_account_id(account: &[u8]) -> PvqResult<()> {
    if account.len() != 32 {
        return Err(PvqError::invalid_input(
            "account_id",
            "32 bytes",
            &format!("{} bytes", account.len())
        ));
    }
    Ok(())
}

pub fn validate_asset_id(asset_id: u32) -> PvqResult<()> {
    if asset_id == 0 {
        return Err(PvqError::invalid_input(
            "asset_id",
            "non-zero value", 
            "0"
        ));
    }
    Ok(())
}

pub fn validate_program_size(program: &[u8]) -> PvqResult<()> {
    if program.len() > MAX_INPUT_SIZE_BYTES {
        return Err(PvqError::ResourceLimitExceeded {
            resource: "program_size".to_string(),
            limit: MAX_INPUT_SIZE_BYTES as u64,
            requested: program.len() as u64,
        });
    }
    Ok(())
}

// Usage in extensions
#[extension_decl]
pub trait ValidatedExtension {
    fn safe_function(account: [u8; 32], asset_id: u32) -> PvqResult<String> {
        validate_account_id(&account)?;
        validate_asset_id(asset_id)?;
        
        // Safe to proceed
        Ok("Validation passed".to_string())
    }
}
```

## Usage Examples

### Basic Error Handling

```rust
use pvq_primitives::{PvqResult, PvqError, PvqResponse};

#[pvq_program::program]
fn safe_query(input: u32) -> PvqResponse<String> {
    match process_input(input) {
        Ok(result) => PvqResponse::success(result),
        Err(error) => PvqResponse::error(
            String::new(),
            error.to_string()
        ),
    }
}

fn process_input(input: u32) -> PvqResult<String> {
    if input == 0 {
        return Err(PvqError::invalid_input(
            "input", 
            "positive number", 
            "0"
        ));
    }
    
    Ok(format!("Processed: {}", input))
}
```

### Complex Data Structures

```rust
use pvq_primitives::{QueryData, QueryMetadata};
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct AnalysisQuery {
    pub assets: Vec<u32>,
    pub accounts: Vec<[u8; 32]>,
    pub include_metadata: bool,
}

#[derive(Serialize, Deserialize)]  
pub struct AnalysisResult {
    pub total_value: u128,
    pub asset_distribution: Vec<(u32, u128)>,
    pub top_holders: Vec<([u8; 32], u128)>,
}

#[pvq_program::program]
fn complex_analysis(query: QueryData<AnalysisQuery>) -> PvqResponse<AnalysisResult> {
    let start_time = current_timestamp();
    
    // Process query
    let result = perform_analysis(&query.payload)?;
    
    // Create response with metadata
    let mut response = PvqResponse::success(result);
    response.metadata.execution_time_ms = current_timestamp() - start_time;
    
    response
}
```

## Integration

### Runtime Integration

Configure primitives in your runtime:

```rust
impl pvq_primitives::Config for Runtime {
    type MaxQuerySize = ConstU32<1048576>; // 1MB
    type MaxResponseSize = ConstU32<10485760>; // 10MB
    type ErrorStringLimit = ConstU32<256>;
}
```

### Extension Integration

Use primitives in extensions:

```rust
use pvq_primitives::{PvqResult, PvqError, ExtensionMetadata};

#[extensions_impl]
impl MyExtension for MyExtensionImpl {
    fn get_metadata() -> ExtensionMetadata {
        ExtensionMetadata {
            name: "MyExtension".to_string(),
            version: "1.0.0".to_string(),
            description: "Custom extension example".to_string(),
            functions: vec![
                // Function metadata...
            ],
        }
    }
    
    fn safe_operation(input: u32) -> PvqResult<String> {
        if input > 1000 {
            return Err(PvqError::invalid_input(
                "input",
                "value <= 1000",
                &input.to_string()
            ));
        }
        
        Ok(format!("Result: {}", input * 2))
    }
}
```

## Development

### Building

```bash
# Build primitives
cargo build -p pvq-primitives

# Run tests
cargo test -p pvq-primitives

# Check documentation
cargo doc -p pvq-primitives --open
```

### Testing

```bash
# Unit tests
cargo test -p pvq-primitives

# Integration tests
cargo test -p pvq-primitives --test integration

# Test serialization performance
cargo bench -p pvq-primitives
```

## Performance Considerations

### Memory Efficiency

- Use compact serialization formats when possible
- Implement custom `Encode`/`Decode` for hot paths
- Avoid unnecessary allocations in error paths

### Error Handling

- Error construction should be lightweight
- Consider error code enums for frequently occurring errors
- Provide context without excessive string allocation

```rust
// Efficient error handling
#[derive(Debug, Clone, Copy)]
pub enum ErrorCode {
    InvalidInput = 1001,
    PermissionDenied = 1002,
    ResourceExhausted = 1003,
    Timeout = 1004,
}

impl From<ErrorCode> for PvqError {
    fn from(code: ErrorCode) -> Self {
        match code {
            ErrorCode::InvalidInput => PvqError::InvalidInput {
                field: "unknown".to_string(),
                expected: "valid input".to_string(),
                received: "invalid".to_string(),
            },
            // ... other mappings
        }
    }
}
```

## Related Components

- [PVQ Executor](../pvq-executor/) - Execution environment
- [PVQ Extension System](../pvq-extension/) - Extension framework
- [PVQ Program](../pvq-program/) - Program development
- [PVQ Runtime API](../pvq-runtime-api/) - Runtime integration

---

*PVQ Primitives provide the essential building blocks for all PVQ system components.*