# PVQ Program

<!-- generated by polka.codes -->

Development tools and procedural macros for creating PVQ (PolkaVM Query) guest programs. This crate provides the `#[program]` macro and supporting utilities that simplify writing queries that run inside PolkaVM.

## Overview

PVQ Program provides the essential tools for developing guest programs that execute within the PVQ system. The `#[program]` macro handles all the boilerplate code required to make your functions executable by the PVQ executor, while additional utilities help with development and debugging.

## Features

- 🚀 **`#[program]` Macro**: Automatically generates program entry points and serialization code
- 📦 **Zero Boilerplate**: Focus on query logic, not infrastructure  
- 🔄 **Automatic Serialization**: Seamless input/output parameter handling
- ⚡ **Optimized Code Generation**: Efficient PolkaVM-compatible code
- 🛠️ **Development Tools**: Utilities for testing and debugging programs
- 📋 **Metadata Generation**: Automatic program metadata for UI integration

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                   PVQ Program                               │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │    Program      │  │   Code Gen      │  │   Dev Tools  │ │
│  │     Macro       │  │                 │  │              │ │
│  │                 │  │ ├─ Entry Point  │  │ ├─ Testing    │ │
│  │ ├─ Parsing      │  │ ├─ Serialization│  │ ├─ Debugging  │ │
│  │ ├─ Validation   │  │ ├─ Error        │  │ ├─ Profiling  │ │
│  │ ├─ Transform    │  │ │  Handling     │  │ └─ Metadata   │ │
│  │ └─ Generation   │  │ └─ Export       │  │    Generation │ │
│  │                 │  │    Functions    │  │              │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## Getting Started

### Basic Program

The simplest PVQ program using the `#[program]` macro:

```rust
use pvq_program::program;

#[program]
fn hello_world() -> String {
    "Hello from PVQ!".to_string()
}
```

This generates all the necessary boilerplate to make your function executable as a PVQ program.

### Program with Parameters

Programs can accept parameters that are automatically deserialized:

```rust
use pvq_program::program;

#[program]
fn add_numbers(a: u32, b: u32) -> u32 {
    a + b
}

#[program]
fn process_account(account_id: [u8; 32], multiplier: u64) -> u64 {
    // Your logic here
    account_id[0] as u64 * multiplier
}
```

### Complex Data Types

Programs support complex input and output types:

```rust
use pvq_program::program;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct QueryInput {
    pub asset_ids: Vec<u32>,
    pub account: [u8; 32],
    pub include_metadata: bool,
}

#[derive(Serialize, Deserialize)]
pub struct QueryResult {
    pub total_balance: u128,
    pub asset_balances: Vec<(u32, u128)>,
    pub metadata: Option<String>,
}

#[program]
fn complex_query(input: QueryInput) -> QueryResult {
    // Implementation here
    QueryResult {
        total_balance: 1000,
        asset_balances: vec![(1, 500), (2, 500)],
        metadata: if input.include_metadata {
            Some("Sample metadata".to_string())
        } else {
            None
        },
    }
}
```

## Program Development

### Using Extensions

Programs can call extension functions to interact with the runtime:

```rust
use pvq_program::program;
use pvq_extension_core::ExtensionCore;
use pvq_extension_fungibles::ExtensionFungibles;

#[program]
fn get_balance_with_info(asset_id: u32, account: [u8; 32]) -> String {
    // Check if fungibles extension is available
    if !ExtensionCore::extension_exists("fungibles") {
        return "Fungibles extension not available".to_string();
    }
    
    // Get balance using extension
    let balance = ExtensionFungibles::balance(asset_id, &account);
    let block = ExtensionCore::current_block_number();
    
    format!("Balance: {} at block {}", balance, block)
}
```

### Error Handling

Programs can return `Result` types for error handling:

```rust
use pvq_program::program;
use pvq_primitives::PvqResult;

#[program]
fn safe_divide(a: u64, b: u64) -> PvqResult<u64> {
    if b == 0 {
        Err(pvq_primitives::PvqError::invalid_input(
            "divisor",
            "non-zero value",
            "0"
        ))
    } else {
        Ok(a / b)
    }
}
```

### Advanced Programs

More complex programs with multiple operations:

```rust
use pvq_program::program;
use pvq_extension_fungibles::ExtensionFungibles;
use pvq_extension_swap::ExtensionSwap;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct PortfolioAnalysis {
    pub total_value: u128,
    pub asset_count: u32,
    pub largest_holding: (u32, u128),
    pub trading_opportunities: Vec<String>,
}

#[program]
fn analyze_portfolio(account: [u8; 32]) -> PortfolioAnalysis {
    let mut analysis = PortfolioAnalysis {
        total_value: 0,
        asset_count: 0,
        largest_holding: (0, 0),
        trading_opportunities: Vec::new(),
    };
    
    // Get all assets
    let assets = ExtensionFungibles::list_assets();
    
    for asset_id in assets {
        let balance = ExtensionFungibles::balance(asset_id, &account);
        
        if balance > 0 {
            analysis.total_value += balance;
            analysis.asset_count += 1;
            
            // Track largest holding
            if balance > analysis.largest_holding.1 {
                analysis.largest_holding = (asset_id, balance);
            }
            
            // Look for trading opportunities
            if balance > 1000 {
                let pools = ExtensionSwap::pools_for_asset(asset_id);
                if !pools.is_empty() {
                    analysis.trading_opportunities.push(
                        format!("Consider trading asset {} (balance: {})", asset_id, balance)
                    );
                }
            }
        }
    }
    
    analysis
}
```

## Program Attributes

### Basic Attributes

The `#[program]` macro supports various attributes:

```rust
use pvq_program::program;

// Basic program
#[program]
fn basic_function() -> u32 { 42 }

// Program with custom name (affects metadata)
#[program(name = "custom_name")]
fn function_with_custom_name() -> String {
    "Custom named function".to_string()
}

// Program with description
#[program(description = "This function demonstrates documentation")]
fn documented_function() -> String {
    "Documented function".to_string()
}
```

### Performance Attributes

```rust
use pvq_program::program;

// Optimize for size
#[program(optimize = "size")]
fn size_optimized() -> u32 { 123 }

// Optimize for speed  
#[program(optimize = "speed")]
fn speed_optimized() -> u64 { 456 }

// Set maximum execution time (milliseconds)
#[program(timeout = 5000)]
fn time_limited() -> String {
    "Completes within 5 seconds".to_string()
}
```

### Memory Attributes

```rust
use pvq_program::program;

// Set maximum memory usage (bytes)
#[program(max_memory = 1048576)] // 1MB
fn memory_limited() -> Vec<u32> {
    vec![1, 2, 3, 4, 5]
}

// Stack size configuration
#[program(stack_size = 65536)] // 64KB
fn custom_stack() -> String {
    "Custom stack size".to_string()
}
```

## Development Tools

### Testing Programs

PVQ Program provides utilities for testing programs locally:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use pvq_program::testing::ProgramTester;
    
    #[test]
    fn test_my_program() {
        let tester = ProgramTester::new();
        
        // Test basic function
        let result = tester.call_program(hello_world, ());
        assert_eq!(result, "Hello from PVQ!");
        
        // Test function with parameters
        let result = tester.call_program(add_numbers, (10, 20));
        assert_eq!(result, 30);
    }
    
    #[test]
    fn test_with_extensions() {
        let mut tester = ProgramTester::new();
        tester.enable_extension("core");
        tester.enable_extension("fungibles");
        
        // Mock extension responses
        tester.mock_extension_call(
            "fungibles",
            "balance",
            vec![1u32, [0u8; 32]],
            1000u128
        );
        
        let result = tester.call_program(get_balance_with_info, (1u32, [0u8; 32]));
        assert!(result.contains("Balance: 1000"));
    }
}
```

### Debugging Support

Enable debugging features during development:

```rust
use pvq_program::{program, debug};

#[program]
fn debug_example(input: u32) -> u32 {
    debug!("Input value: {}", input);
    
    let result = input * 2;
    debug!("Calculated result: {}", result);
    
    result
}

// Run with debugging enabled
// RUST_LOG=pvq_program=debug cargo run
```

### Profiling

Profile program performance:

```rust
use pvq_program::{program, profile};

#[program]
fn performance_example() -> u64 {
    let _timer = profile!("main_calculation");
    
    let mut result = 0u64;
    for i in 0..1000000 {
        result += i;
    }
    
    result
}
```

## Metadata Generation

### Automatic Metadata

The macro automatically generates metadata for UI integration:

```rust
use pvq_program::program;

/// Calculate the sum of account balances for multiple assets
/// 
/// # Parameters
/// - `accounts`: List of account IDs to check
/// - `asset_ids`: List of assets to include in calculation
/// 
/// # Returns
/// Total balance across all accounts and assets
#[program(
    name = "multi_asset_balance",
    version = "1.0.0",
    author = "Developer Name"
)]
fn calculate_multi_asset_balance(
    accounts: Vec<[u8; 32]>,
    asset_ids: Vec<u32>
) -> u128 {
    // Implementation
    0
}
```

This generates metadata that can be used by UIs to provide documentation and type information.

### Custom Metadata

Add custom metadata fields:

```rust
use pvq_program::program;

#[program(
    name = "advanced_query",
    description = "Performs advanced portfolio analysis",
    version = "2.1.0",
    author = "Portfolio Team",
    tags = ["finance", "portfolio", "analysis"],
    complexity = "high",
    estimated_gas = 50000
)]
fn advanced_portfolio_query() -> String {
    "Advanced analysis result".to_string()
}
```

## Build Integration

### Cargo Configuration

Add to your `Cargo.toml`:

```toml
[dependencies]
pvq-program = { version = "0.1.0", default-features = false }
pvq-extension-core = { version = "0.1.0", default-features = false }
pvq-extension-fungibles = { version = "0.1.0", default-features = false }
pvq-primitives = { version = "0.1.0", default-features = false }
serde = { version = "1.0", default-features = false, features = ["derive"] }

[features]
default = []
std = [
    "pvq-program/std",
    "pvq-primitives/std",
    "serde/std",
]
```

### Build Script Integration

For metadata generation, add `build.rs`:

```rust
use std::env;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    // Generate program metadata
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    
    let status = Command::new("pvq-program-metadata-gen")
        .arg("--crate-path")
        .arg(env::current_dir().unwrap())
        .arg("--output-dir") 
        .arg(&out_dir)
        .status()
        .expect("Failed to run metadata generator");
        
    if !status.success() {
        panic!("Metadata generation failed");
    }
    
    println!("cargo:rerun-if-changed=src/");
}
```

## Advanced Usage

### Custom Serialization

For performance-critical programs, implement custom serialization:

```rust
use pvq_program::{program, custom_serde};

#[derive(Clone)]
pub struct CustomData {
    pub values: Vec<u64>,
    pub flags: u32,
}

impl custom_serde::Serialize for CustomData {
    fn serialize(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend((self.values.len() as u32).to_le_bytes());
        for &val in &self.values {
            bytes.extend(val.to_le_bytes());
        }
        bytes.extend(self.flags.to_le_bytes());
        bytes
    }
}

impl custom_serde::Deserialize for CustomData {
    fn deserialize(bytes: &[u8]) -> Result<Self, String> {
        if bytes.len() < 8 {
            return Err("Insufficient data".to_string());
        }
        
        let len = u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]) as usize;
        let mut values = Vec::with_capacity(len);
        
        for i in 0..len {
            let start = 4 + i * 8;
            if start + 8 > bytes.len() {
                return Err("Truncated data".to_string());
            }
            let val = u64::from_le_bytes([
                bytes[start], bytes[start + 1], bytes[start + 2], bytes[start + 3],
                bytes[start + 4], bytes[start + 5], bytes[start + 6], bytes[start + 7],
            ]);
            values.push(val);
        }
        
        let flags_start = 4 + len * 8;
        if flags_start + 4 > bytes.len() {
            return Err("No flags data".to_string());
        }
        
        let flags = u32::from_le_bytes([
            bytes[flags_start], bytes[flags_start + 1],
            bytes[flags_start + 2], bytes[flags_start + 3],
        ]);
        
        Ok(CustomData { values, flags })
    }
}

#[program]
fn process_custom_data(data: CustomData) -> u64 {
    data.values.iter().sum::<u64>() + data.flags as u64
}
```

### Multi-Function Programs

Create programs with multiple entry points:

```rust
use pvq_program::{program, program_module};

#[program_module]
mod my_programs {
    use super::*;
    
    #[program]
    pub fn query_balance(account: [u8; 32]) -> u128 {
        // Implementation
        0
    }
    
    #[program]
    pub fn query_metadata(asset_id: u32) -> String {
        // Implementation
        "Metadata".to_string()
    }
    
    #[program]
    pub fn complex_analysis(params: AnalysisParams) -> AnalysisResult {
        // Implementation
        AnalysisResult::default()
    }
}
```

## Performance Optimization

### Size Optimization

For size-constrained environments:

```rust
use pvq_program::program;

// Minimize code size
#[program(optimize = "size", inline_threshold = 0)]
fn minimal_program() -> u32 {
    42
}

// Avoid large dependencies
#[program]
fn efficient_program(input: u32) -> u32 {
    // Use simple operations instead of complex libraries
    input.wrapping_mul(2).wrapping_add(1)
}
```

### Speed Optimization

For performance-critical programs:

```rust
use pvq_program::program;

// Optimize for speed
#[program(optimize = "speed", inline_aggressive = true)]
fn fast_program(data: Vec<u32>) -> u64 {
    data.into_iter()
        .map(|x| x as u64)
        .sum()
}

// Use efficient algorithms
#[program]
fn optimized_search(haystack: Vec<u32>, needle: u32) -> Option<usize> {
    // Binary search for sorted data
    haystack.binary_search(&needle).ok()
}
```

## Troubleshooting

### Common Issues

**Program won't compile:**
```bash
# Check for syntax errors in macro usage
cargo check

# Enable detailed error reporting
RUST_BACKTRACE=1 cargo build
```

**Serialization errors:**
```rust
// Ensure all types implement required traits
#[derive(serde::Serialize, serde::Deserialize)]
pub struct MyType {
    pub field: u32,
}
```

**Runtime errors:**
```rust
// Add error handling
#[program]
fn safe_program(input: u32) -> Result<u32, String> {
    if input == 0 {
        Err("Zero input not allowed".to_string())
    } else {
        Ok(input * 2)
    }
}
```

### Debug Mode

Enable debug output:

```bash
# Build with debug info
RUST_LOG=debug cargo build

# Run test with debug output
RUST_LOG=pvq_program=debug cargo test
```

## Related Components

- [PVQ Executor](../pvq-executor/) - Program execution environment
- [PVQ Extension System](../pvq-extension/) - Extension framework
- [PVQ Program Metadata Gen](../pvq-program-metadata-gen/) - Metadata generation
- [PVQ Test Runner](../pvq-test-runner/) - Testing utilities

---

*PVQ Program provides the tools to create efficient, type-safe guest programs for the PVQ system.*