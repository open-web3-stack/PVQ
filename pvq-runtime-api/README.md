# PVQ Runtime API

<!-- generated by polka.codes -->

The Substrate runtime API definition for PVQ (PolkaVM Query) that provides the interface between external clients and the PVQ execution system. This crate defines the `PvqApi` trait that runtime implementations must provide to support PVQ functionality.

## Overview

The PVQ Runtime API serves as the bridge between external clients (like UIs, CLIs, or other applications) and the PVQ execution system within Substrate runtimes. It provides a standardized interface for submitting queries, retrieving results, and accessing system metadata.

## Features

- ğŸŒ **Standard Interface**: Consistent API across different runtime implementations
- ğŸ” **Query Execution**: Submit and execute PVQ programs with arguments
- ğŸ“Š **Metadata Access**: Retrieve information about available extensions and capabilities
- âš¡ **Async Support**: Compatible with Substrate's async runtime API system
- ğŸ›¡ï¸ **Type Safety**: Strongly-typed interface with compile-time guarantees
- ğŸ“ˆ **Performance Metrics**: Built-in execution statistics and monitoring

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PVQ Runtime API                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚    PvqApi       â”‚  â”‚   Client Side   â”‚  â”‚   Runtime    â”‚ â”‚
â”‚  â”‚    Trait        â”‚  â”‚                 â”‚  â”‚   Side       â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚ â”œâ”€ Query        â”‚  â”‚              â”‚ â”‚
â”‚  â”‚ â”œâ”€ execute      â”‚  â”‚ â”‚  Submission   â”‚  â”‚ â”œâ”€ Executor   â”‚ â”‚
â”‚  â”‚ â”‚  _query       â”‚  â”‚ â”œâ”€ Result       â”‚  â”‚ â”‚  Instance   â”‚ â”‚
â”‚  â”‚ â”œâ”€ metadata     â”‚  â”‚ â”‚  Processing   â”‚  â”‚ â”œâ”€ Extension  â”‚ â”‚
â”‚  â”‚ â”œâ”€ capabilities â”‚  â”‚ â”œâ”€ Error        â”‚  â”‚ â”‚  Registry   â”‚ â”‚
â”‚  â”‚ â””â”€ version      â”‚  â”‚ â”‚  Handling     â”‚  â”‚ â””â”€ Context    â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚ â””â”€ Async        â”‚  â”‚    Management â”‚ â”‚
â”‚  â”‚                 â”‚  â”‚    Support      â”‚  â”‚              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## API Definition

### Core Trait

The main runtime API trait that must be implemented:

```rust
use sp_api::decl_runtime_apis;
use pvq_primitives::{PvqResult, QueryMetadata};

decl_runtime_apis! {
    /// PVQ Runtime API for executing queries and managing the system
    pub trait PvqApi {
        /// Execute a PVQ program with given arguments
        /// 
        /// # Parameters
        /// - `program`: Compiled PVQ program blob (PolkaVM bytecode)
        /// - `args`: Serialized arguments for the program
        /// 
        /// # Returns  
        /// Serialized result of program execution
        fn execute_query(program: Vec<u8>, args: Vec<u8>) -> Vec<u8>;
        
        /// Get metadata about the PVQ system and available extensions
        /// 
        /// # Returns
        /// Serialized system metadata including extension information
        fn metadata() -> Vec<u8>;
        
        /// Get system capabilities and configuration
        /// 
        /// # Returns
        /// Serialized capability information
        fn capabilities() -> Vec<u8>;
        
        /// Get the PVQ system version information
        /// 
        /// # Returns
        /// Version string
        fn version() -> String;
    }
}
```

## Runtime Implementation

### Basic Implementation

Implementing the API in your runtime:

```rust
use sp_api::impl_runtime_apis;
use pvq_executor::{PvqExecutor, PvqExecutorContext};
use pvq_extension::ExtensionsExecutor;
use pvq_extension_core::ExtensionCore;
use pvq_extension_fungibles::ExtensionFungibles;
use pvq_extension_swap::ExtensionSwap;

impl_runtime_apis! {
    impl pvq_runtime_api::PvqApi<Block> for Runtime {
        fn execute_query(program: Vec<u8>, args: Vec<u8>) -> Vec<u8> {
            // Create extension executor with available extensions
            let mut extensions = ExtensionsExecutor::new();
            extensions.register::<ExtensionCore>();
            extensions.register::<ExtensionFungibles>();
            extensions.register::<ExtensionSwap>();
            
            // Create execution context
            let context = PvqExecutorContext::new(extensions);
            
            // Create and configure executor
            let executor = PvqExecutor::new(context);
            
            // Execute program
            match executor.execute(&program, &args) {
                Ok(result) => result,
                Err(error) => {
                    // Return error as serialized response
                    format!("Error: {}", error).into_bytes()
                }
            }
        }
        
        fn metadata() -> Vec<u8> {
            let metadata = SystemMetadata {
                version: "1.0.0".to_string(),
                extensions: vec![
                    "core".to_string(),
                    "fungibles".to_string(), 
                    "swap".to_string(),
                ],
                max_execution_time_ms: 30000,
                max_memory_bytes: 64 * 1024 * 1024,
            };
            
            serde_json::to_vec(&metadata).unwrap_or_default()
        }
        
        fn capabilities() -> Vec<u8> {
            let capabilities = SystemCapabilities {
                supported_program_versions: vec!["1.0".to_string()],
                max_program_size_bytes: 1024 * 1024,
                max_args_size_bytes: 1024 * 1024,
                max_result_size_bytes: 10 * 1024 * 1024,
                execution_timeout_ms: 30000,
            };
            
            serde_json::to_vec(&capabilities).unwrap_or_default()
        }
        
        fn version() -> String {
            "PVQ Runtime API v1.0.0".to_string()
        }
    }
}
```

### Advanced Implementation

More sophisticated implementation with error handling and monitoring:

```rust
use pvq_primitives::{PvqResponse, QueryMetadata, PvqError};
use std::time::Instant;

impl_runtime_apis! {
    impl pvq_runtime_api::PvqApi<Block> for Runtime {
        fn execute_query(program: Vec<u8>, args: Vec<u8>) -> Vec<u8> {
            let start_time = Instant::now();
            let mut query_metadata = QueryMetadata::new();
            
            // Validate input sizes
            if program.len() > MAX_PROGRAM_SIZE {
                let error = PvqError::ResourceLimitExceeded {
                    resource: "program_size".to_string(),
                    limit: MAX_PROGRAM_SIZE as u64,
                    requested: program.len() as u64,
                };
                return Self::create_error_response(error, query_metadata);
            }
            
            // Set up extensions with runtime context
            let mut extensions = ExtensionsExecutor::new();
            Self::configure_extensions(&mut extensions);
            
            // Create execution context with monitoring
            let context = PvqExecutorContext::builder()
                .with_extensions(extensions)
                .with_block_number(Self::current_block_number())
                .with_monitoring(true)
                .build();
            
            // Execute with timeout and resource limits
            let executor = PvqExecutor::builder()
                .with_context(context)
                .with_timeout(Duration::from_secs(30))
                .with_memory_limit(64 * 1024 * 1024)
                .build();
            
            match executor.execute(&program, &args) {
                Ok(result) => {
                    query_metadata.execution_time_ms = start_time.elapsed().as_millis() as u64;
                    query_metadata.memory_used_bytes = executor.memory_usage();
                    query_metadata.extension_calls = executor.extension_call_count();
                    query_metadata.block_number = Self::current_block_number();
                    
                    let response = PvqResponse {
                        data: result,
                        metadata: query_metadata,
                        success: true,
                    };
                    
                    serde_json::to_vec(&response).unwrap_or_default()
                }
                Err(error) => {
                    query_metadata.execution_time_ms = start_time.elapsed().as_millis() as u64;
                    query_metadata.error_message = Some(error.to_string());
                    Self::create_error_response(error, query_metadata)
                }
            }
        }
        
        fn metadata() -> Vec<u8> {
            let extensions_metadata = Self::get_extensions_metadata();
            
            let metadata = SystemMetadata {
                version: env!("CARGO_PKG_VERSION").to_string(),
                runtime_version: Self::runtime_version().to_string(),
                extensions: extensions_metadata,
                limits: SystemLimits {
                    max_execution_time_ms: MAX_EXECUTION_TIME_MS,
                    max_memory_bytes: MAX_MEMORY_BYTES,
                    max_program_size: MAX_PROGRAM_SIZE,
                    max_args_size: MAX_ARGS_SIZE,
                },
                features: SystemFeatures {
                    async_execution: true,
                    permission_control: true,
                    performance_monitoring: true,
                },
            };
            
            serde_json::to_vec(&metadata).unwrap_or_default()
        }
        
        fn capabilities() -> Vec<u8> {
            let capabilities = SystemCapabilities::builder()
                .with_program_versions(vec!["1.0".to_string()])
                .with_serialization_formats(vec!["json".to_string(), "scale".to_string()])
                .with_extension_discovery(true)
                .with_batch_execution(false) // Future feature
                .build();
            
            serde_json::to_vec(&capabilities).unwrap_or_default()
        }
        
        fn version() -> String {
            format!("PVQ Runtime API v{}", env!("CARGO_PKG_VERSION"))
        }
    }
}

impl Runtime {
    fn configure_extensions(executor: &mut ExtensionsExecutor) {
        // Register core extensions
        executor.register::<ExtensionCore>();
        
        // Register fungibles extension if assets pallet is available
        if Self::has_assets_pallet() {
            executor.register::<ExtensionFungibles>();
        }
        
        // Register swap extension if DEX pallet is available
        if Self::has_dex_pallet() {
            executor.register::<ExtensionSwap>();
        }
        
        // Register custom runtime-specific extensions
        Self::register_custom_extensions(executor);
    }
    
    fn create_error_response(error: PvqError, metadata: QueryMetadata) -> Vec<u8> {
        let response = PvqResponse {
            data: Vec::new(),
            metadata,
            success: false,
        };
        
        serde_json::to_vec(&response).unwrap_or_else(|_| {
            format!(r#"{{"error": "{}"}}"#, error).into_bytes()
        })
    }
}
```

## Client Usage

### Direct API Calls

Using the API from client code:

```rust
use sp_api::ProvideRuntimeApi;
use pvq_runtime_api::PvqApi;

// In your client code
async fn execute_pvq_program<Client>(
    client: &Client,
    program: Vec<u8>,
    args: Vec<u8>,
) -> Result<Vec<u8>, Box<dyn std::error::Error>>
where
    Client: ProvideRuntimeApi<Block>,
    Client::Api: PvqApi<Block>,
{
    let at = client.info().best_hash;
    
    let result = client
        .runtime_api()
        .execute_query(at, program, args)?;
    
    Ok(result)
}

async fn get_system_metadata<Client>(
    client: &Client,
) -> Result<SystemMetadata, Box<dyn std::error::Error>>
where
    Client: ProvideRuntimeApi<Block>,
    Client::Api: PvqApi<Block>,
{
    let at = client.info().best_hash;
    
    let metadata_bytes = client
        .runtime_api()
        .metadata(at)?;
    
    let metadata: SystemMetadata = serde_json::from_slice(&metadata_bytes)?;
    Ok(metadata)
}
```

### RPC Integration

Wrapping the API for RPC access:

```rust
use jsonrpsee::{core::RpcResult, proc_macros::rpc};
use sp_api::ProvideRuntimeApi;
use pvq_runtime_api::PvqApi;

#[rpc(client, server)]
pub trait PvqRpcApi {
    /// Execute a PVQ program
    #[method(name = "pvq_executeQuery")]
    async fn execute_query(
        &self,
        program: String, // Hex-encoded program
        args: String,    // Hex-encoded arguments
    ) -> RpcResult<String>; // Hex-encoded result
    
    /// Get system metadata
    #[method(name = "pvq_metadata")]
    async fn metadata(&self) -> RpcResult<serde_json::Value>;
    
    /// Get system capabilities
    #[method(name = "pvq_capabilities")]
    async fn capabilities(&self) -> RpcResult<serde_json::Value>;
    
    /// Get version information
    #[method(name = "pvq_version")]
    async fn version(&self) -> RpcResult<String>;
}

pub struct PvqRpc<Client> {
    client: Arc<Client>,
}

impl<Client> PvqRpc<Client> {
    pub fn new(client: Arc<Client>) -> Self {
        Self { client }
    }
}

impl<Client> PvqRpcApiServer for PvqRpc<Client>
where
    Client: ProvideRuntimeApi<Block> + Send + Sync + 'static,
    Client::Api: PvqApi<Block>,
{
    async fn execute_query(
        &self,
        program_hex: String,
        args_hex: String,
    ) -> RpcResult<String> {
        let program = hex::decode(program_hex)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Invalid program hex: {}", e)))?;
        
        let args = hex::decode(args_hex)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Invalid args hex: {}", e)))?;
        
        let at = self.client.info().best_hash;
        
        let result = self.client
            .runtime_api()
            .execute_query(at, program, args)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Execution failed: {}", e)))?;
        
        Ok(hex::encode(result))
    }
    
    async fn metadata(&self) -> RpcResult<serde_json::Value> {
        let at = self.client.info().best_hash;
        
        let metadata_bytes = self.client
            .runtime_api()
            .metadata(at)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Failed to get metadata: {}", e)))?;
        
        let metadata: serde_json::Value = serde_json::from_slice(&metadata_bytes)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Failed to parse metadata: {}", e)))?;
        
        Ok(metadata)
    }
    
    async fn capabilities(&self) -> RpcResult<serde_json::Value> {
        let at = self.client.info().best_hash;
        
        let capabilities_bytes = self.client
            .runtime_api()
            .capabilities(at)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Failed to get capabilities: {}", e)))?;
        
        let capabilities: serde_json::Value = serde_json::from_slice(&capabilities_bytes)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Failed to parse capabilities: {}", e)))?;
        
        Ok(capabilities)
    }
    
    async fn version(&self) -> RpcResult<String> {
        let at = self.client.info().best_hash;
        
        let version = self.client
            .runtime_api()
            .version(at)
            .map_err(|e| jsonrpsee::core::Error::Custom(format!("Failed to get version: {}", e)))?;
        
        Ok(version)
    }
}
```

## Data Types

### System Metadata

Information about the PVQ system:

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SystemMetadata {
    pub version: String,
    pub runtime_version: String,
    pub extensions: Vec<ExtensionInfo>,
    pub limits: SystemLimits,
    pub features: SystemFeatures,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ExtensionInfo {
    pub name: String,
    pub version: String,
    pub description: String,
    pub functions: Vec<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SystemLimits {
    pub max_execution_time_ms: u64,
    pub max_memory_bytes: u64,
    pub max_program_size: usize,
    pub max_args_size: usize,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SystemFeatures {
    pub async_execution: bool,
    pub permission_control: bool,
    pub performance_monitoring: bool,
}
```

### System Capabilities

Runtime capability information:

```rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SystemCapabilities {
    pub supported_program_versions: Vec<String>,
    pub serialization_formats: Vec<String>,
    pub max_program_size_bytes: usize,
    pub max_args_size_bytes: usize,
    pub max_result_size_bytes: usize,
    pub execution_timeout_ms: u64,
    pub extension_discovery: bool,
    pub batch_execution: bool,
}
```

## Configuration

### Runtime Configuration

Configure API behavior in your runtime:

```rust
parameter_types! {
    pub const MaxProgramSize: u32 = 1024 * 1024; // 1MB
    pub const MaxArgsSize: u32 = 1024 * 1024; // 1MB
    pub const MaxResultSize: u32 = 10 * 1024 * 1024; // 10MB
    pub const ExecutionTimeout: u64 = 30000; // 30 seconds
}

impl pvq_runtime_api::Config for Runtime {
    type MaxProgramSize = MaxProgramSize;
    type MaxArgsSize = MaxArgsSize;
    type MaxResultSize = MaxResultSize;
    type ExecutionTimeout = ExecutionTimeout;
}
```

### Feature Gates

Control API features:

```rust
#[cfg(feature = "pvq-api")]
impl_runtime_apis! {
    impl pvq_runtime_api::PvqApi<Block> for Runtime {
        // Implementation here
    }
}
```

## Development

### Building

```bash
# Build runtime API
cargo build -p pvq-runtime-api

# Build with all features
cargo build -p pvq-runtime-api --all-features

# Generate documentation
cargo doc -p pvq-runtime-api --open
```

### Testing

```bash
# Unit tests
cargo test -p pvq-runtime-api

# Integration tests with runtime
cargo test -p pvq-runtime-api --test runtime_integration

# Test RPC functionality
cargo test -p pvq-runtime-api --test rpc_tests
```

## Performance Considerations

### Optimization Tips

1. **Cache Extension Registry**: Avoid recreating extensions on each call
2. **Limit Result Size**: Implement size limits to prevent resource exhaustion  
3. **Async Execution**: Use async where possible for better concurrency
4. **Memory Management**: Monitor and limit memory usage during execution

### Example Optimizations

```rust
impl Runtime {
    // Cache extension registry
    thread_local! {
        static EXTENSION_CACHE: RefCell<Option<ExtensionsExecutor>> = RefCell::new(None);
    }
    
    fn get_cached_extensions() -> ExtensionsExecutor {
        Self::EXTENSION_CACHE.with(|cache| {
            let mut cache = cache.borrow_mut();
            if cache.is_none() {
                let mut extensions = ExtensionsExecutor::new();
                Self::configure_extensions(&mut extensions);
                *cache = Some(extensions);
            }
            cache.as_ref().unwrap().clone()
        })
    }
}
```

## Security Considerations

- Validate all input data before processing
- Implement proper resource limits and timeouts
- Use sandboxed execution environment  
- Log and monitor API usage
- Rate limit API calls if exposed publicly

## Error Handling

Handle API errors gracefully:

```rust
impl Runtime {
    fn handle_api_error(error: PvqError) -> Vec<u8> {
        let response = match error {
            PvqError::Timeout { duration_ms } => {
                ApiResponse::timeout(duration_ms)
            }
            PvqError::ResourceLimitExceeded { resource, .. } => {
                ApiResponse::resource_exhausted(resource)
            }
            _ => {
                ApiResponse::general_error(error.to_string())
            }
        };
        
        serde_json::to_vec(&response).unwrap_or_default()
    }
}
```

## Related Components

- [PVQ Executor](../pvq-executor/) - Execution environment
- [PVQ Extension System](../pvq-extension/) - Extension framework  
- [PVQ Primitives](../pvq-primitives/) - Core types
- [PoC Runtime](../poc/runtime/) - Example implementation

---

*The PVQ Runtime API provides the standard interface for integrating PVQ functionality into Substrate runtimes.*