# PVQ Test Runner

<!-- generated by polka.codes -->

A comprehensive testing and development tool for PVQ (PolkaVM Query) programs. The test runner provides a simulated environment for executing guest programs, validating results, and debugging query logic without requiring a full runtime deployment.

## Overview

The PVQ Test Runner serves as an essential development tool that enables developers to test their PVQ programs locally, validate extension interactions, and debug program logic in a controlled environment. It simulates the complete PVQ execution environment including extensions, permissions, and resource limits.

## Features

- 🧪 **Local Testing**: Execute PVQ programs without a full runtime environment
- 🎯 **Extension Simulation**: Mock extension calls and responses for testing
- 🔍 **Detailed Logging**: Comprehensive execution tracing and debugging information
- ⚡ **Performance Profiling**: Measure execution time, memory usage, and resource consumption
- 🛡️ **Error Simulation**: Test error handling and edge cases
- 📊 **Result Validation**: Compare actual vs. expected results with detailed diffs
- 🔧 **Configuration Options**: Flexible testing scenarios and environment setup

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                  PVQ Test Runner                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   Test Runner   │  │   Simulation    │  │   Reporting  │ │
│  │                 │  │   Environment   │  │              │ │
│  │ ├─ Program      │  │                 │  │              │ │
│  │ │  Loading      │  │ ├─ Extension    │  │ ├─ Results    │ │
│  │ ├─ Execution    │  │ │  Mocking      │  │ │  Analysis   │ │
│  │ │  Management   │  │ ├─ State        │  │ ├─ Performance│ │
│  │ ├─ Result       │  │ │  Management   │  │ │  Metrics    │ │
│  │ │  Validation   │  │ ├─ Permission   │  │ ├─ Error      │ │
│  │ └─ Configuration│  │ │  Control      │  │ │  Reports    │ │
│  │                 │  │ └─ Resource     │  │ └─ Debug      │ │
│  │                 │  │    Limits       │  │    Output     │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## Installation

### From Source

```bash
# Clone the PVQ repository
git clone --recursive https://github.com/open-web3-stack/PVQ.git
cd PVQ

# Build the test runner
cargo build -p pvq-test-runner --release

# The binary will be available at target/release/pvq-test-runner
```

### Global Installation

```bash
# Install globally via cargo
cargo install --path pvq-test-runner

# Or install from crates.io (when published)
cargo install pvq-test-runner
```

## Usage

### Basic Usage

```bash
# Run a compiled PVQ program
pvq-test-runner --program output/my-program.polkavm

# Run with custom arguments
pvq-test-runner --program output/my-program.polkavm --args "arg1,arg2,arg3"

# Run with hex-encoded arguments
pvq-test-runner --program output/my-program.polkavm --args-hex "0x010203040506"
```

### Command Line Options

```bash
pvq-test-runner [OPTIONS] --program <PROGRAM>

Options:
    -p, --program <PROGRAM>              Path to the compiled PVQ program
    -a, --args <ARGS>                    Comma-separated program arguments
        --args-hex <ARGS_HEX>            Hex-encoded program arguments
    -c, --config <CONFIG>                Path to configuration file
    -o, --output <OUTPUT>                Output format (json, yaml, pretty)
    -v, --verbose                        Enable verbose logging
        --debug                          Enable debug mode with detailed tracing
        --profile                        Enable performance profiling
        --timeout <TIMEOUT>              Execution timeout in seconds [default: 30]
        --memory-limit <MEMORY_LIMIT>    Memory limit in MB [default: 64]
        --extensions <EXTENSIONS>        Comma-separated list of enabled extensions
        --mock-file <MOCK_FILE>          Path to extension mock configuration
        --validate <VALIDATE>            Path to expected result file for validation
        --no-color                       Disable colored output
    -h, --help                           Print help information
    -V, --version                        Print version information
```

## Configuration

### Configuration File

Create a `test-config.toml` for complex testing scenarios:

```toml
[program]
path = "output/my-program.polkavm"
timeout_seconds = 30
memory_limit_mb = 64

[execution]
enable_debugging = true
enable_profiling = true
trace_extension_calls = true
max_call_depth = 256

[extensions]
enabled = ["core", "fungibles", "swap"]

[extensions.fungibles]
mock_balance_responses = true
default_balance = 1000

[extensions.swap]
mock_pool_data = true
default_pool_reserves = [10000, 20000]

[logging]
level = "debug"
format = "pretty"
include_timestamps = true

[validation]
expected_result_file = "tests/expected_results.json"
tolerance = 0.001  # For floating point comparisons
```

### Extension Mocking

Create mock configurations for testing:

```json
{
  "extension_mocks": {
    "fungibles": {
      "balance": {
        "default_response": 1000,
        "specific_responses": {
          "[1, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]": 5000,
          "[2, [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]": 2500
        }
      },
      "total_supply": {
        "default_response": 1000000,
        "specific_responses": {
          "[1]": 500000,
          "[2]": 750000
        }
      }
    },
    "swap": {
      "pool_reserves": {
        "default_response": [10000, 20000],
        "specific_responses": {
          "[{\"asset_0\": 1, \"asset_1\": 2}]": [15000, 25000]
        }
      }
    }
  }
}
```

## Testing Scenarios

### Basic Program Testing

```bash
# Test a simple balance query program
pvq-test-runner --program output/balance-query.polkavm \
  --args "1,0x0101010101010101010101010101010101010101010101010101010101010101" \
  --extensions "core,fungibles" \
  --verbose
```

### Complex Integration Testing

```bash
# Test with comprehensive configuration
pvq-test-runner \
  --config test-scenarios/portfolio-analysis.toml \
  --mock-file test-data/market-data-mocks.json \
  --validate test-data/expected-portfolio-result.json \
  --profile \
  --output json
```

### Performance Testing

```bash
# Performance benchmark
pvq-test-runner --program output/performance-test.polkavm \
  --profile \
  --timeout 60 \
  --memory-limit 128 \
  --debug
```

## Development Integration

### Automated Testing

Integrate with your development workflow:

```bash
#!/bin/bash
# test-all-programs.sh

set -e

echo "Building all guest programs..."
make guests

echo "Running tests..."

for program in output/*.polkavm; do
    echo "Testing $(basename $program)..."
    pvq-test-runner --program "$program" \
      --config "tests/$(basename $program .polkavm).toml" \
      --validate "tests/expected/$(basename $program .polkavm).json"
done

echo "All tests passed!"
```

### CI/CD Integration

GitHub Actions example:

```yaml
name: PVQ Program Tests

on: [push, pull_request]

jobs:
  test-programs:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: recursive
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
    
    - name: Install tools
      run: make tools
    
    - name: Build guest programs
      run: make guests
    
    - name: Run PVQ tests
      run: |
        for program in output/*.polkavm; do
          cargo run -p pvq-test-runner -- \
            --program "$program" \
            --config "tests/$(basename $program .polkavm).toml"
        done
```

## API Reference

### Programmatic Usage

Use the test runner as a library:

```rust
use pvq_test_runner::{TestRunner, TestConfig, ExtensionMock};
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create test configuration
    let config = TestConfig::builder()
        .with_timeout(Duration::from_secs(30))
        .with_memory_limit(64 * 1024 * 1024)
        .with_extensions(vec!["core", "fungibles"])
        .enable_profiling(true)
        .enable_debugging(true)
        .build();
    
    // Set up extension mocks
    let mut mocks = HashMap::new();
    mocks.insert(
        "fungibles.balance".to_string(),
        ExtensionMock::simple_response(serde_json::json!(1000))
    );
    
    // Create and configure test runner
    let mut runner = TestRunner::new(config);
    runner.set_extension_mocks(mocks);
    
    // Load and execute program
    let program = std::fs::read("output/my-program.polkavm")?;
    let args = serde_json::to_vec(&(1u32, [0u8; 32]))?;
    
    let result = runner.execute_program(&program, &args).await?;
    
    // Analyze results
    println!("Execution successful: {}", result.success);
    println!("Result: {:?}", result.output);
    println!("Execution time: {}ms", result.execution_time_ms);
    println!("Memory used: {} bytes", result.memory_used_bytes);
    
    if let Some(profile) = result.profile {
        println!("Performance profile:");
        for (operation, duration) in profile.operation_times {
            println!("  {}: {}ms", operation, duration.as_millis());
        }
    }
    
    Ok(())
}
```

### Test Utilities

Helper functions for common testing patterns:

```rust
use pvq_test_runner::testing::*;

#[tokio::test]
async fn test_balance_query() {
    let mut tester = create_default_tester().await;
    
    // Mock balance response
    tester.mock_extension_call(
        "fungibles", 
        "balance", 
        vec![json!(1), json!([0u8; 32])],
        json!(5000)
    );
    
    // Execute test
    let result = tester.execute_program_file(
        "output/balance-query.polkavm",
        &(1u32, [0u8; 32])
    ).await.unwrap();
    
    // Validate result
    assert!(result.success);
    let balance: u128 = serde_json::from_slice(&result.output).unwrap();
    assert_eq!(balance, 5000);
}

#[tokio::test]
async fn test_error_handling() {
    let mut tester = create_default_tester().await;
    
    // Mock extension error
    tester.mock_extension_error(
        "fungibles",
        "balance", 
        "Asset not found"
    );
    
    let result = tester.execute_program_file(
        "output/balance-query.polkavm",
        &(999u32, [0u8; 32])
    ).await.unwrap();
    
    // Should handle error gracefully
    assert!(result.success); // Program should handle error
    let response: String = serde_json::from_slice(&result.output).unwrap();
    assert!(response.contains("Asset not found"));
}
```

## Output Formats

### Pretty Output (Default)

```
PVQ Test Runner v0.1.0
======================

Program: output/balance-query.polkavm
Arguments: [1, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

Execution Results:
├─ Status: ✓ Success
├─ Output: 1000
├─ Execution Time: 15ms
├─ Memory Used: 2.1MB
├─ Extension Calls: 3
│  ├─ core.current_block_number: 1 call
│  └─ fungibles.balance: 1 call
└─ Block Number: 12345

Performance Profile:
├─ Program Loading: 2ms
├─ Extension Setup: 1ms  
├─ Program Execution: 10ms
└─ Result Serialization: 2ms
```

### JSON Output

```json
{
  "success": true,
  "program": "output/balance-query.polkavm",
  "arguments": "[1, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]",
  "output": "1000",
  "execution_time_ms": 15,
  "memory_used_bytes": 2097152,
  "extension_calls": {
    "total": 2,
    "by_extension": {
      "core": 1,
      "fungibles": 1
    }
  },
  "block_number": 12345,
  "profile": {
    "program_loading_ms": 2,
    "extension_setup_ms": 1,
    "program_execution_ms": 10,
    "result_serialization_ms": 2
  },
  "error": null
}
```

### YAML Output

```yaml
success: true
program: output/balance-query.polkavm
arguments: "[1, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]"
output: "1000"
execution_time_ms: 15
memory_used_bytes: 2097152
extension_calls:
  total: 2
  by_extension:
    core: 1
    fungibles: 1
block_number: 12345
profile:
  program_loading_ms: 2
  extension_setup_ms: 1
  program_execution_ms: 10
  result_serialization_ms: 2
error: null
```

## Advanced Features

### Custom Validators

Create custom result validation:

```rust
use pvq_test_runner::{TestRunner, ValidationRule, ValidationResult};

struct BalanceRangeValidator {
    min: u128,
    max: u128,
}

impl ValidationRule for BalanceRangeValidator {
    fn validate(&self, output: &[u8]) -> ValidationResult {
        match serde_json::from_slice::<u128>(output) {
            Ok(balance) => {
                if balance >= self.min && balance <= self.max {
                    ValidationResult::success()
                } else {
                    ValidationResult::failure(format!(
                        "Balance {} outside expected range [{}, {}]",
                        balance, self.min, self.max
                    ))
                }
            }
            Err(e) => ValidationResult::error(format!("Failed to parse balance: {}", e)),
        }
    }
}

// Usage
let mut runner = TestRunner::new(config);
runner.add_validator(Box::new(BalanceRangeValidator { 
    min: 100, 
    max: 10000 
}));
```

### Extension Development Testing

Test custom extensions:

```rust
use pvq_test_runner::extension_testing::ExtensionTester;

#[tokio::test]
async fn test_custom_extension() {
    let mut tester = ExtensionTester::new();
    
    // Register custom extension
    tester.register_extension::<MyCustomExtension>();
    
    // Test extension directly
    let result = tester.call_extension(
        "my_custom_extension",
        "my_function",
        vec![json!("test_input")]
    ).await.unwrap();
    
    assert_eq!(result, json!("expected_output"));
    
    // Test in program context
    let program_result = tester.execute_program_with_extension(
        "output/custom-extension-test.polkavm",
        &("test_input",)
    ).await.unwrap();
    
    assert!(program_result.success);
}
```

## Debugging

### Debug Mode

Enable comprehensive debugging:

```bash
# Enable all debug output
pvq-test-runner --program output/my-program.polkavm --debug

# Specific debug categories
RUST_LOG=pvq_test_runner=debug,pvq_executor=trace pvq-test-runner \
  --program output/my-program.polkavm
```

### Trace Output

Example trace output:

```
[DEBUG pvq_test_runner] Loading program: output/balance-query.polkavm
[TRACE pvq_executor] Creating PolkaVM instance
[DEBUG pvq_extension] Registering extension: core
[DEBUG pvq_extension] Registering extension: fungibles  
[TRACE pvq_executor] Program loaded, size: 4096 bytes
[DEBUG pvq_test_runner] Executing with args: [1, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]
[TRACE pvq_executor] Starting program execution
[DEBUG pvq_extension] Extension call: core.current_block_number() -> 12345
[DEBUG pvq_extension] Extension call: fungibles.balance(1, [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) -> 1000
[TRACE pvq_executor] Program execution completed
[DEBUG pvq_test_runner] Result: 1000
```

## Performance Analysis

### Profiling Reports

Detailed performance analysis:

```
Performance Analysis Report
===========================

Program: output/complex-analysis.polkavm
Total Execution Time: 245ms

Breakdown:
├─ Program Loading: 5ms (2.0%)
├─ Extension Setup: 3ms (1.2%)  
├─ Program Execution: 230ms (93.9%)
│  ├─ Extension Calls: 45ms (18.4%)
│  │  ├─ fungibles.list_assets: 5ms
│  │  ├─ fungibles.balance (×10): 25ms  
│  │  └─ swap.pool_info (×5): 15ms
│  └─ Program Logic: 185ms (75.5%)
└─ Result Serialization: 7ms (2.9%)

Memory Usage:
├─ Peak Usage: 12.5MB
├─ Average Usage: 8.2MB
└─ Final Usage: 1.1MB

Extension Call Statistics:
├─ Total Calls: 16
├─ Average Call Time: 2.8ms
├─ Slowest Call: swap.pool_info (4.2ms)
└─ Most Frequent: fungibles.balance (10 calls)
```

### Optimization Suggestions

The test runner provides optimization hints:

```
Optimization Suggestions:
========================

🔍 Performance Issues Detected:
├─ High extension call overhead (18.4% of execution time)
│  └─ Consider batching balance queries into single operation
├─ Memory fragmentation detected
│  └─ Consider using Vec::with_capacity for known-size collections  
└─ Serialization overhead significant (2.9%)
   └─ Consider using more efficient serialization format

✅ Good Practices Observed:
├─ Efficient extension usage patterns
├─ Proper error handling
└─ Minimal memory allocations in hot paths
```

## Troubleshooting

### Common Issues

**Program won't load:**
```bash
# Check program format
file output/my-program.polkavm

# Verify program was built correctly
ls -la output/my-program.polkavm

# Try with minimal configuration
pvq-test-runner --program output/my-program.polkavm --extensions core
```

**Extension errors:**
```bash
# Enable extension debug logging
RUST_LOG=pvq_extension=debug pvq-test-runner --program output/my-program.polkavm

# Check available extensions
pvq-test-runner --program output/my-program.polkavm --extensions core --debug
```

**Memory issues:**
```bash
# Increase memory limit
pvq-test-runner --program output/my-program.polkavm --memory-limit 128

# Enable memory profiling
pvq-test-runner --program output/my-program.polkavm --profile --debug
```

## Related Components

- [PVQ Program](../pvq-program/) - Program development tools
- [PVQ Executor](../pvq-executor/) - Execution environment  
- [PVQ Extension System](../pvq-extension/) - Extension framework
- [PVQ Program Metadata Gen](../pvq-program-metadata-gen/) - Metadata generation

---

*The PVQ Test Runner provides comprehensive testing and development support for PVQ programs.*