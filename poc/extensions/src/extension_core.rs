use super::Dispatchable;
use super::ExtensionError;
use super::ExtensionTypeId;
use parity_scale_codec::{Decode, Encode};
// SDK codes
pub trait ExtensionCore: Dispatchable + TryFrom<(u32, Vec<u8>)> {
    // ExtensionId should be generated by the macro
    // It should normalize the order of methods and parameter names
    const TYPE_ID: ExtensionTypeId = 0u64;
    type ArgsOfSomeHostFunction;
    type ResultOfSomeHostFunction;
    fn some_host_function(args: Self::ArgsOfSomeHostFunction) -> Self::ResultOfSomeHostFunction;
}

// User impls: handwritten

#[derive(Encode, Decode)]
pub struct ArgsImpl {
    pub a: u32,
    pub b: u32,
}

impl ExtensionCore for ExtensionCoreImpl {
    type ArgsOfSomeHostFunction = ArgsImpl;
    type ResultOfSomeHostFunction = u32;
    fn some_host_function(args: Self::ArgsOfSomeHostFunction) -> Self::ResultOfSomeHostFunction {
        args.a + args.b
    }
}

// User impls: generated
impl Dispatchable for ExtensionCoreImpl {
    type MethodName = Vec<u8>;
    type MethodIndex = u32;
    fn query_method(method_name: Self::MethodName) -> Self::MethodIndex {
        match method_name.as_slice() {
            b"query_method" => 0,
            b"some_host_function" => 1,
            _ => Self::MethodIndex::MAX,
        }
    }
    fn dispatch(self) -> Vec<u8> {
        match self {
            Self::QueryMethod { method_name } => Self::query_method(method_name).encode(),
            Self::SomeHostFunction { args } => Self::some_host_function(args).encode(),
        }
    }
}
pub enum ExtensionCoreImpl {
    // args can be decoded later or here
    QueryMethod {
        method_name: <Self as Dispatchable>::MethodName,
    },
    SomeHostFunction {
        args: ArgsImpl,
    },
}

impl TryFrom<(u32, Vec<u8>)> for ExtensionCoreImpl {
    type Error = ExtensionError;
    fn try_from((method_idx, args): (u32, Vec<u8>)) -> Result<Self, Self::Error> {
        match method_idx {
            0 => Ok(Self::QueryMethod {
                method_name: <Self as Dispatchable>::MethodName::decode(&mut &args[..])
                    .map_err(Self::Error::DecodeError)?,
            }),
            1 => {
                let args = ArgsImpl::decode(&mut &args[..]).map_err(Self::Error::DecodeError)?;
                Ok(Self::SomeHostFunction { args })
            }
            _ => Err(Self::Error::UnsupportedMethod),
        }
    }
}
