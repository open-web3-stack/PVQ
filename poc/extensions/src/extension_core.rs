use crate::DispatchError;
use crate::Dispatchable;
use crate::ExtensionTypeId;
use parity_scale_codec::{Decode, Encode};
// SDK codes
pub trait ExtensionCore {
    // ExtensionId should be generated by the macro
    // It should normalize the order of methods and parameter names
    const TYPE_ID: ExtensionTypeId = 0u64;
    type Config: Config;
    fn some_host_function(
        args: <Self::Config as Config>::ArgsOfSomeHostFunction,
    ) -> <Self::Config as Config>::ResultOfSomeHostFunction;
}

pub trait Config {
    type Call: Dispatchable + Encode + Decode;
    type ArgsOfSomeHostFunction;
    type ResultOfSomeHostFunction;
}

// User impls: handwritten
pub struct ExtensionCoreImpl;

#[derive(Encode, Decode)]
pub struct ArgsImpl {
    pub a: u32,
    pub b: u32,
}

pub struct ConfigImpl;
impl Config for ConfigImpl {
    // this associated type is generated by the macro
    type Call = ExtensionCoreImplCall;
    type ArgsOfSomeHostFunction = ArgsImpl;
    type ResultOfSomeHostFunction = u32;
}

impl ExtensionCore for ExtensionCoreImpl {
    type Config = ConfigImpl;
    fn some_host_function(
        args: <Self::Config as Config>::ArgsOfSomeHostFunction,
    ) -> <Self::Config as Config>::ResultOfSomeHostFunction {
        args.a + args.b
    }
}

// User impls: generated
// Proxy enum for dispatching all extension functions
#[derive(Encode, Decode)]
pub enum ExtensionCoreImplCall {
    // args can be decoded later or here
    SomeHostFunction { args: ArgsImpl },
}

impl Dispatchable for ExtensionCoreImplCall {
    fn dispatch(self) -> Result<Vec<u8>, DispatchError> {
        match self {
            Self::SomeHostFunction { args } => Ok(ExtensionCoreImpl::some_host_function(args).encode()),
        }
    }
}
