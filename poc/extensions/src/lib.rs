#![cfg_attr(not(feature = "std"), no_std)]
use core::marker::PhantomData;
use parity_scale_codec::{Decode, Encode, Error as CodeCError};
use poc_executor::{XcqExecutor, XcqExecutorContext};
#[cfg(not(feature = "std"))]
use scale_info::prelude::{format, string::String};
pub type XcqResponse = Vec<u8>;
pub type XcqError = String;
pub type XcqResult = Result<XcqResponse, XcqError>;

mod extension_core;
pub use extension_core::ExtensionCore;
mod extension_fungibles;
pub use extension_fungibles::ExtensionFungibles;
mod guest;
pub use guest::{Guest, Input};
mod dispatchable;
pub use dispatchable::{DispatchError, Dispatchable, ExtensionTypeId};

mod macros;

// TODO: contain source error
pub enum ExtensionError {
    PolkavmError,
    DecodeError(CodeCError),
    DispatchError(DispatchError),
    UnsupportedExtension,
}
// Aggregated struct for all extension functions that runtime supports
// Generated by some macros
pub struct HostFunctions<E1: ExtensionCore, E2: ExtensionFungibles> {
    phantom: PhantomData<(E1, E2)>,
}

// Generated by some macros
impl<E1: ExtensionCore, E2: ExtensionFungibles> XcqExecutorContext for HostFunctions<E1, E2> {
    fn register_host_functions<T>(&mut self, linker: &mut poc_executor::Linker<T>) {
        linker
            .func_wrap(
                "_",
                |mut caller: poc_executor::Caller<_>,
                 extension_id: u64,
                 call_ptr: u32,
                 call_len: u32,
                 res_ptr: u32|
                 -> u32 {
                    // useful closure to handle early return
                    let mut func_with_result = || -> Result<u32, ExtensionError> {
                        // TODO: first check if the caller has the permission to call the extension
                        let call_bytes = caller
                            .read_memory_into_vec(call_ptr, call_len)
                            .map_err(|_| ExtensionError::PolkavmError)?;
                        // If we want to use match, we need construct a ExtensionId enum
                        // since plain number cannot be checked exhaustively
                        let res_bytes = if extension_id == E1::TYPE_ID {
                            let method = <E1::Config as extension_core::Config>::Call::decode(&mut &call_bytes[..])
                                .map_err(ExtensionError::DecodeError)?;
                            method.dispatch().map_err(ExtensionError::DispatchError)?
                        } else if extension_id == E2::TYPE_ID {
                            let method =
                                <E2::Config as extension_fungibles::Config>::Call::decode(&mut &call_bytes[..])
                                    .map_err(ExtensionError::DecodeError)?;
                            method.dispatch().map_err(ExtensionError::DispatchError)?
                        } else {
                            return Err(ExtensionError::UnsupportedExtension);
                        };
                        caller
                            .write_memory(res_ptr, &res_bytes[..])
                            .map_err(|_| ExtensionError::PolkavmError)?;
                        Ok(res_bytes.len() as u32)
                    };
                    func_with_result().unwrap_or(0)
                },
            )
            .unwrap();
    }
}

// Original From
// #[some_macro]
// struct ExtensionsExecutor {
//     E1: ExtensionCore
//     E2: ExtensionFungibles
// }
// Expanded
// In practice, generics are generated by macros
struct ExtensionsExecutor<E1: ExtensionCore, E2: ExtensionFungibles> {
    executor: XcqExecutor<HostFunctions<E1, E2>>,
}
impl<E1: ExtensionCore, E2: ExtensionFungibles> ExtensionsExecutor<E1, E2> {
    // Generated by macro
    #[allow(dead_code)]
    pub fn new() -> Self {
        let host_functions = HostFunctions::<E1, E2> {
            phantom: core::marker::PhantomData,
        };
        let executor = XcqExecutor::new(Default::default(), host_functions);
        Self { executor }
    }
    // In PoC, guest and input are opaque to the runtime
    // In SDK, we can make them has type
    #[allow(dead_code)]
    fn execute_method<G: Guest, I: Input>(&mut self, guest: G, input: I) -> XcqResult {
        let extension_id = guest.type_id();
        // TODO: Check if the runtime supports the extension
        if extension_id != E1::TYPE_ID || extension_id != E2::TYPE_ID {
            return Err(format!("Unsupported extension: {}", extension_id));
        };
        self.executor
            .execute(guest.program(), input.method(), input.args())
            .map_err(|e| format!("{:?}", e))
    }
}

#[cfg(test)]
mod tests {
    use super::extension_core::ExtensionCoreImpl;
    use super::extension_fungibles::ExtensionFungiblesImpl;
    use super::guest::{GuestImpl, InputImpl};
    use super::*;

    // TODO: refine the test
    #[test]
    fn extensions_executor_fails() {
        let mut executor = ExtensionsExecutor::<ExtensionCoreImpl, ExtensionFungiblesImpl>::new();
        let guest = GuestImpl {
            extension_type: 0u64,
            program: vec![0, 1, 2, 3],
        };
        let input = InputImpl {
            method: "main".to_string(),
            args: vec![0, 1, 2, 3],
        };
        let res = executor.execute_method(guest, input);
        assert!(res.is_err())
    }
}
