#![cfg_attr(not(feature = "std"), no_std)]
use poc_executor::{XcqExecutor, XcqExecutorContext};
#[cfg(not(feature = "std"))]
use scale_info::prelude::{format, string::String};
pub type XcqResponse = Vec<u8>;
pub type XcqError = String;
pub type XcqResult = Result<XcqResponse, XcqError>;

mod extension_core;
pub use extension_core::ExtensionCore;
mod extension_fungibles;
pub use extension_fungibles::ExtensionFungibles;
mod guest;
pub use guest::{Guest, Input};

mod macros;

type Error = String;

type ExtensionTypeId = u64;
// General trait for all extension interfaces
pub trait Extension {
    fn methods(&self) -> Vec<String>;
}

// Aggregated struct for all extension functions that runtime supports
// Generated by some macros
pub struct HostFunctions<E1: ExtensionCore, E2: ExtensionFungibles> {
    phantom: core::marker::PhantomData<(E1, E2)>,
}

// Generated by some macros
impl<E1: ExtensionCore, E2: ExtensionFungibles> XcqExecutorContext for HostFunctions<E1, E2> {
    fn register_host_functions<T>(&mut self, linker: &mut poc_executor::Linker<T>) {
        // As aforementioned, we may use macros to directly copy the functions impls to here
        linker
            .func_wrap("some_host_function", move || -> u32 {
                <E1 as ExtensionCore>::some_host_function()
            })
            .unwrap();
        linker
            .func_wrap("another_host_function", || -> u32 {
                <E1 as ExtensionCore>::another_host_function()
            })
            .unwrap();
        linker
            .func_wrap("transfer", move |from: u32, to: u32, amount: u64| -> u64 {
                <E2 as ExtensionFungibles>::transfer(from, to, amount)
            })
            .unwrap();
        linker
            .func_wrap("balance", move |account: u32| -> u64 {
                <E2 as ExtensionFungibles>::balance(account)
            })
            .unwrap();
    }
}

// pub trait ExtensionsExecutor {
//     type ExecutorType;
//     fn from_extensions()->
//     fn execute_method(&self, guest: Guest, input: Input) -> XcqResult;
// }

// Expanded
// In practice, generics are generated by macros
struct ExtensionsExecutor<E1: ExtensionCore, E2: ExtensionFungibles> {
    executor: XcqExecutor<HostFunctions<E1, E2>>,
}
impl<E1: ExtensionCore, E2: ExtensionFungibles> ExtensionsExecutor<E1, E2> {
    // Generated by macro
    pub fn from_extensions(_extension_core: E1, _extension_fungibles: E2) -> Self {
        let host_functions = HostFunctions::<E1, E2> {
            phantom: core::marker::PhantomData,
        };
        let executor = XcqExecutor::new(Default::default(), host_functions);
        Self { executor }
    }
    // In PoC, guest and input are opague to the runtime
    // In SDK, we can make them has type
    fn execute_method<G: Guest, I: Input>(&self, guest: G, input: I) -> XcqResult {
        let extension_id = guest.type_id();
        // In practice, these match statements should be generated by some macros
        // Check if the runtime supports the extension
        match extension_id {
            // TODO: E1, E2 information are discarded after `HostFunctions` is generated
            // How to fix it?
            E1::TYPE_ID | E2::TYPE_ID => {}
            _ => return Err(format!("Unsupported extension: {}", extension_id)),
        }
        self.executor
            .execute(guest.program(), input.method(), input.args())
            .map_err(|e| format!("{:?}", e))
    }
}
