#![cfg_attr(not(feature = "std"), no_std)]
use core::marker::PhantomData;
use parity_scale_codec::Error as CodeCError;
use poc_executor::{XcqExecutor, XcqExecutorContext};
#[cfg(not(feature = "std"))]
use scale_info::prelude::{format, string::String};
pub type XcqResponse = Vec<u8>;
pub type XcqError = String;
pub type XcqResult = Result<XcqResponse, XcqError>;

mod extension_core;
pub use extension_core::ExtensionCore;
mod extension_fungibles;
pub use extension_fungibles::ExtensionFungibles;
mod guest;
pub use guest::{Guest, Input};
mod dispatchable;
pub use dispatchable::{Dispatchable, ExtensionTypeId};

mod macros;

pub enum ExtensionError {
    DecodeError(CodeCError),
    UnsupportedMethod,
}
// Aggregated struct for all extension functions that runtime supports
// Generated by some macros
pub struct HostFunctions<E1: ExtensionCore, E2: ExtensionFungibles> {
    phantom: PhantomData<(E1, E2)>,
}

// Generated by some macros
impl<E1: ExtensionCore, E2: ExtensionFungibles> XcqExecutorContext for HostFunctions<E1, E2> {
    fn register_host_functions<T>(&mut self, linker: &mut poc_executor::Linker<T>) {
        linker
            .func_wrap(
                "_",
                |mut caller: poc_executor::Caller<_>,
                 extension_id: u64,
                 method_idx: u32,
                 args_ptr: u32,
                 args_len: u32,
                 res_ptr: u32|
                 -> u32 {
                    let args_bytes = caller
                        .read_memory_into_vec(args_ptr, args_len)
                        .expect("read_memory_into_vec failed");
                    // TODO: If we want to use match, we need construct a ExtensionId enum
                    // since plain number cannot be checked exhaustively
                    if extension_id == E1::TYPE_ID {
                        let method = match E1::try_from((method_idx, args_bytes)) {
                            Ok(method) => method,
                            Err(_) => {
                                return 0;
                            }
                        };
                        let res_bytes = method.dispatch();
                        caller.write_memory(res_ptr, &res_bytes[..]).unwrap();
                        res_bytes.len() as u32
                    } else if extension_id == E2::TYPE_ID {
                        let method = match E2::try_from((method_idx, args_bytes)) {
                            Ok(method) => method,
                            Err(_) => {
                                return 0;
                            }
                        };
                        let res_bytes = method.dispatch();
                        caller.write_memory(res_ptr, &res_bytes[..]).unwrap();
                        res_bytes.len() as u32
                    } else {
                        0
                    }
                },
            )
            .unwrap();
    }
}

// Original From
// #[some_macro]
// struct ExtensionsExecutor {
//     E1: ExtensionCore
//     E2: ExtensionFungibles
// }
// Expanded
// In practice, generics are generated by macros
struct ExtensionsExecutor<E1: ExtensionCore, E2: ExtensionFungibles> {
    executor: XcqExecutor<HostFunctions<E1, E2>>,
}
impl<E1: ExtensionCore, E2: ExtensionFungibles> ExtensionsExecutor<E1, E2> {
    // Generated by macro
    #[allow(dead_code)]
    pub fn new() -> Self {
        let host_functions = HostFunctions::<E1, E2> {
            phantom: core::marker::PhantomData,
        };
        let executor = XcqExecutor::new(Default::default(), host_functions);
        Self { executor }
    }
    // In PoC, guest and input are opague to the runtime
    // In SDK, we can make them has type
    #[allow(dead_code)]
    fn execute_method<G: Guest, I: Input>(&mut self, guest: G, input: I) -> XcqResult {
        let extension_id = guest.type_id();
        // TODO: Check if the runtime supports the extension
        if extension_id != E1::TYPE_ID || extension_id != E2::TYPE_ID {
            return Err(format!("Unsupported extension: {}", extension_id));
        };
        self.executor
            .execute(guest.program(), input.method(), input.args())
            .map_err(|e| format!("{:?}", e))
    }
}

#[cfg(test)]
mod tests {
    use super::extension_core::ExtensionCoreImpl;
    use super::extension_fungibles::ExtensionFungiblesImpl;
    use super::guest::{GuestImpl, InputImpl};
    use super::*;

    // TODO: refine the test
    #[test]
    fn extensions_executor_fails() {
        let mut executor = ExtensionsExecutor::<ExtensionCoreImpl, ExtensionFungiblesImpl>::new();
        let guest = GuestImpl {
            extension_type: 0u64,
            program: vec![0, 1, 2, 3],
        };
        let input = InputImpl {
            method: "main".to_string(),
            args: vec![0, 1, 2, 3],
        };
        let res = executor.execute_method(guest, input);
        assert!(res.is_err())
    }
}
