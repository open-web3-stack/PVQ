use super::Dispatchable;
use super::ExtensionError;
use super::ExtensionTypeId;
use parity_scale_codec::{Decode, Encode};
pub trait ExtensionFungibles: Dispatchable + TryFrom<(u32, Vec<u8>)> {
    // ExtensionId should be generated by the macro
    // It should normalize the order of methods and parameter names
    const TYPE_ID: ExtensionTypeId = 1u64;
    // TODO: In practice, these type are defined together in Config
    type AccountId;
    type Balance;
    fn transfer(from: Self::AccountId, to: Self::AccountId, amount: Self::Balance) -> Self::Balance;
    fn balance(account: Self::AccountId) -> Self::Balance;
}

impl ExtensionFungibles for ExtensionFungiblesImpl {
    type AccountId = u32;
    type Balance = u64;
    fn transfer(_from: Self::AccountId, _to: Self::AccountId, _amount: Self::Balance) -> Self::Balance {
        unimplemented!()
    }
    fn balance(_account: u32) -> Self::Balance {
        unimplemented!()
    }
}

// User impls: generated
impl Dispatchable for ExtensionFungiblesImpl {
    type MethodName = Vec<u8>;
    type MethodIndex = u32;
    fn query_method(method_name: Self::MethodName) -> Self::MethodIndex {
        match method_name.as_slice() {
            b"query_method" => 0,
            b"transfer" => 1,
            b"balance" => 2,
            _ => Self::MethodIndex::MAX,
        }
    }
    fn dispatch(self) -> Vec<u8> {
        match self {
            Self::QueryMethod { method_name } => Self::query_method(method_name).encode(),
            Self::Transfer { from, to, amount } => Self::transfer(from, to, amount).encode(),
            Self::Balance_ { account } => Self::balance(account).encode(),
        }
    }
}
pub enum ExtensionFungiblesImpl {
    QueryMethod {
        method_name: <Self as Dispatchable>::MethodName,
    },
    Transfer {
        from: u32,
        to: u32,
        amount: u64,
    },
    // Differentiate with associated type Balance
    Balance_ {
        account: u32,
    },
}

impl TryFrom<(u32, Vec<u8>)> for ExtensionFungiblesImpl {
    type Error = ExtensionError;
    fn try_from((method_idx, args): (u32, Vec<u8>)) -> Result<Self, Self::Error> {
        match method_idx {
            0 => Ok(Self::QueryMethod {
                method_name: <Self as Dispatchable>::MethodName::decode(&mut &args[..])
                    .map_err(Self::Error::DecodeError)?,
            }),
            1 => {
                // This struct encoding must be compatible with the guest side
                #[derive(Encode, Decode)]
                struct TransferArgs {
                    from: u32,
                    to: u32,
                    amount: u64,
                }
                let args = TransferArgs::decode(&mut &args[..]).map_err(Self::Error::DecodeError)?;
                Ok(Self::Transfer {
                    from: args.from,
                    to: args.to,
                    amount: args.amount,
                })
            }
            2 => {
                #[derive(Encode, Decode)]
                struct BalanceArgs {
                    account: u32,
                }
                let args = BalanceArgs::decode(&mut &args[..]).map_err(Self::Error::DecodeError)?;
                Ok(Self::Balance_ { account: args.account })
            }
            _ => Err(Self::Error::UnsupportedMethod),
        }
    }
}
