# PVQ Extension System

<!-- generated by polka.codes -->

The foundational extension framework for PVQ (PolkaVM Query) that enables modular and secure interaction between guest programs and runtime functionality. This system provides the architecture for creating, registering, and executing extensions.

## Overview

The PVQ Extension System serves as the bridge between sandboxed guest programs and the Substrate runtime. It provides a secure, permission-controlled mechanism for exposing runtime functionality to PVQ programs through a modular extension architecture.

## Features

- 🧩 **Modular Architecture**: Plugin-based extension system
- 🔒 **Security Controls**: Fine-grained permission management
- 📝 **Procedural Macros**: Simplified extension development with `#[extension_decl]` and `#[extensions_impl]`
- ⚡ **High Performance**: Optimized call dispatch and execution
- 🛡️ **Type Safety**: Compile-time validation of extension interfaces
- 🔌 **Hot-Pluggable**: Runtime extension registration and discovery

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                PVQ Extension System                         │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   Extension     │  │   Extensions    │  │  Permission  │ │
│  │   Declaration   │  │   Executor      │  │  Controller  │ │
│  │                 │  │                 │  │              │ │
│  │ ├─ Trait Def    │  │ ├─ Registry     │  │ ├─ Access     │ │
│  │ ├─ Metadata     │  │ ├─ Dispatch     │  │ │  Control    │ │
│  │ ├─ Function     │  │ ├─ Context      │  │ ├─ Policy     │ │
│  │ │  Signatures   │  │ │  Management   │  │ │  Engine     │ │
│  │ └─ Validation   │  │ └─ Error        │  │ └─ Audit      │ │
│  │                 │  │    Handling     │  │    Trail      │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## Core Components

### Extension Declaration (`#[extension_decl]`)

Define new extensions using the procedural macro:

```rust
use pvq_extension::extension_decl;

#[extension_decl]
pub trait MyExtension {
    /// Get system information
    fn get_info() -> String;
    
    /// Process data with validation
    fn process_data(input: Vec<u8>) -> Result<Vec<u8>, String>;
    
    /// Query with parameters
    fn query_with_params(id: u32, filter: Option<String>) -> Vec<u32>;
}
```

### Extension Implementation (`#[extensions_impl]`)

Implement extensions for runtime integration:

```rust
use pvq_extension::extensions_impl;

pub struct MyExtensionImpl;

#[extensions_impl]
impl MyExtension for MyExtensionImpl {
    fn get_info() -> String {
        "System v1.0".to_string()
    }
    
    fn process_data(input: Vec<u8>) -> Result<Vec<u8>, String> {
        if input.is_empty() {
            Err("Empty input".to_string())
        } else {
            Ok(input.into_iter().map(|b| b.wrapping_add(1)).collect())
        }
    }
    
    fn query_with_params(id: u32, filter: Option<String>) -> Vec<u32> {
        // Implementation logic
        vec![id]
    }
}
```

### Extensions Executor

Manages extension registration and execution:

```rust
use pvq_extension::ExtensionsExecutor;

let mut executor = ExtensionsExecutor::new();

// Register extensions
executor.register::<MyExtension>();
executor.register::<AnotherExtension>();

// Execute extension calls from guest programs
let result = executor.execute_call("MyExtension", "get_info", &[])?;
```

### Permission Controller

Controls access to extensions and functions:

```rust
use pvq_extension::{PermissionController, Permission};

let mut controller = PermissionController::new();

// Grant specific permissions
controller.grant_permission(
    "guest_program_id",
    Permission::Extension("MyExtension".to_string())
);

// Check permissions before execution
if controller.check_permission("guest_program_id", &permission) {
    // Execute extension call
}
```

## Usage Guide

### Creating a New Extension

1. **Define the Extension Trait:**

```rust
use pvq_extension::extension_decl;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct CustomData {
    pub value: u64,
    pub name: String,
}

#[extension_decl]
pub trait CustomExtension {
    /// Get custom data by ID
    fn get_data(id: u32) -> Option<CustomData>;
    
    /// List all available data IDs  
    fn list_data_ids() -> Vec<u32>;
    
    /// Validate data format
    fn validate_data(data: CustomData) -> bool;
}
```

2. **Implement the Extension:**

```rust
use pvq_extension::extensions_impl;

pub struct CustomExtensionImpl<T> {
    _phantom: std::marker::PhantomData<T>,
}

#[extensions_impl]
impl<T: RuntimeConfig> CustomExtension for CustomExtensionImpl<T> {
    fn get_data(id: u32) -> Option<CustomData> {
        // Access runtime storage
        T::Storage::get_custom_data(id)
    }
    
    fn list_data_ids() -> Vec<u32> {
        T::Storage::list_custom_data_ids()
    }
    
    fn validate_data(data: CustomData) -> bool {
        !data.name.is_empty() && data.value > 0
    }
}
```

3. **Register in Runtime:**

```rust
use pvq_extension::ExtensionsExecutor;

impl pvq_runtime_api::PvqApi<Block> for Runtime {
    fn execute_query(&self, program: Vec<u8>, args: Vec<u8>) -> Vec<u8> {
        let mut extensions = ExtensionsExecutor::new();
        
        // Register standard extensions
        extensions.register::<ExtensionCore>();
        extensions.register::<ExtensionFungibles>();
        
        // Register custom extension
        extensions.register::<CustomExtension>();
        
        // Execute program with extensions
        let context = PvqExecutorContext::new(extensions);
        let executor = PvqExecutor::new(context);
        
        executor.execute(&program, &args).unwrap_or_default()
    }
}
```

### Using Extensions in Guest Programs

```rust
use pvq_program::program;
use custom_extension::CustomExtension;

#[program]
fn query_custom_data(id: u32) -> String {
    match CustomExtension::get_data(id) {
        Some(data) => {
            format!("Data: {} = {}", data.name, data.value)
        }
        None => {
            "Data not found".to_string()
        }
    }
}

#[program] 
fn validate_and_list() -> Vec<u32> {
    let all_ids = CustomExtension::list_data_ids();
    
    all_ids.into_iter()
        .filter(|&id| {
            if let Some(data) = CustomExtension::get_data(id) {
                CustomExtension::validate_data(data)
            } else {
                false
            }
        })
        .collect()
}
```

## Advanced Features

### Permission Management

Configure fine-grained access control:

```rust
use pvq_extension::{PermissionController, Permission, PermissionPolicy};

let mut controller = PermissionController::new();

// Create permission policy
let policy = PermissionPolicy::new()
    .allow_extension("core")
    .allow_extension("fungibles")
    .deny_function("fungibles", "admin_function")
    .with_rate_limit(100, Duration::from_secs(60));

// Apply policy to program
controller.set_policy("program_id", policy);
```

### Extension Metadata

Generate and access extension metadata:

```rust
use pvq_extension::{ExtensionMetadata, FunctionMetadata};

// Metadata is automatically generated from extension declarations
let metadata = ExtensionsExecutor::get_extension_metadata("CustomExtension");

match metadata {
    Some(meta) => {
        println!("Extension: {}", meta.name);
        println!("Version: {}", meta.version);
        
        for function in meta.functions {
            println!("Function: {}", function.name);
            println!("Parameters: {:?}", function.parameters);
            println!("Return Type: {:?}", function.return_type);
        }
    }
    None => println!("Extension not found"),
}
```

### Error Handling

Handle extension errors gracefully:

```rust
use pvq_extension::{ExtensionError, ExtensionResult};

#[extension_decl]
pub trait SafeExtension {
    fn safe_operation(input: u32) -> ExtensionResult<String>;
}

#[extensions_impl]  
impl SafeExtension for SafeExtensionImpl {
    fn safe_operation(input: u32) -> ExtensionResult<String> {
        if input == 0 {
            Err(ExtensionError::InvalidInput("Input cannot be zero".to_string()))
        } else if input > 1000 {
            Err(ExtensionError::OutOfRange("Input too large".to_string()))
        } else {
            Ok(format!("Processed: {}", input))
        }
    }
}
```

## Configuration

### Runtime Configuration

Configure the extension system in your runtime:

```rust
impl pvq_extension::Config for Runtime {
    type MaxExtensions = ConstU32<64>;
    type MaxFunctionsPerExtension = ConstU32<32>;
    type EnablePermissionControl = ConstBool<true>;
    type EnableMetadataGeneration = ConstBool<true>;
}
```

### Extension Registration

Register extensions with configuration:

```rust
use pvq_extension::{ExtensionsExecutor, ExtensionConfig};

let mut executor = ExtensionsExecutor::new();

let config = ExtensionConfig {
    enable_caching: true,
    max_call_depth: 10,
    timeout: Duration::from_secs(30),
};

executor.register_with_config::<MyExtension>(config);
```

## Development Tools

### Testing Extensions

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use pvq_extension::testing::ExtensionTester;
    
    #[test]
    fn test_extension_functionality() {
        let tester = ExtensionTester::new();
        tester.register::<CustomExtension>();
        
        // Test extension calls
        let result = tester.call("CustomExtension", "get_data", &[1u32]);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_permission_enforcement() {
        let mut tester = ExtensionTester::new();
        tester.set_permission_policy(restrictive_policy());
        
        // This should fail due to permissions
        let result = tester.call("CustomExtension", "admin_function", &[]);
        assert!(matches!(result, Err(ExtensionError::PermissionDenied(_))));
    }
}
```

### Debugging

Enable detailed logging:

```rust
use log::debug;

#[extensions_impl]
impl CustomExtension for CustomExtensionImpl {
    fn debug_function(input: String) -> String {
        debug!("CustomExtension::debug_function called with: {}", input);
        
        let result = process_input(&input);
        
        debug!("CustomExtension::debug_function returning: {}", result);
        result
    }
}
```

Run with debug logging:

```bash
RUST_LOG=pvq_extension=debug,custom_extension=debug cargo test
```

## Performance Considerations

### Optimization Tips

1. **Minimize Allocations**: Use stack allocation when possible
2. **Batch Operations**: Group related calls into single functions
3. **Cache Results**: Cache expensive computations within extensions
4. **Limit Recursion**: Avoid deep call chains between extensions

### Benchmarking

```bash
# Benchmark extension performance
cargo bench -p pvq-extension

# Profile extension calls
cargo run --example profile_extensions --release
```

### Example Optimizations

```rust
// Efficient: Batch operation
#[extension_decl]
pub trait OptimizedExtension {
    fn batch_process(items: Vec<ProcessItem>) -> Vec<ProcessResult>;
}

// Less efficient: Individual calls
#[extension_decl] 
pub trait UnoptimizedExtension {
    fn process_single(item: ProcessItem) -> ProcessResult;
}
```

## Security Best Practices

### Input Validation

Always validate inputs in extension implementations:

```rust
#[extensions_impl]
impl SecureExtension for SecureExtensionImpl {
    fn secure_function(user_input: String) -> Result<String, String> {
        // Validate input length
        if user_input.len() > 1000 {
            return Err("Input too long".to_string());
        }
        
        // Validate input format
        if !user_input.chars().all(|c| c.is_alphanumeric()) {
            return Err("Invalid characters".to_string());
        }
        
        // Safe processing
        Ok(process_validated_input(&user_input))
    }
}
```

### Permission Boundaries

Implement proper access controls:

```rust
use pvq_extension::{Permission, PermissionController};

fn setup_permissions() -> PermissionController {
    let mut controller = PermissionController::new();
    
    // Public functions - accessible to all programs
    controller.grant_global_permission(Permission::Function(
        "PublicExtension".to_string(),
        "public_query".to_string()
    ));
    
    // Admin functions - restricted access
    controller.grant_permission(
        "admin_program_id",
        Permission::Function(
            "AdminExtension".to_string(),
            "admin_function".to_string()
        )
    );
    
    controller
}
```

## Migration Guide

### Upgrading Extensions

When updating extension interfaces:

1. **Version your extensions:**

```rust
#[extension_decl]
pub trait MyExtensionV2 {
    // Keep old functions for compatibility
    fn old_function() -> String;
    
    // Add new functions
    fn new_function() -> EnhancedResult;
}
```

2. **Provide migration path:**

```rust
// Implement both versions
impl MyExtension for MyExtensionImpl { /* old implementation */ }
impl MyExtensionV2 for MyExtensionImpl { /* new implementation */ }
```

### Breaking Changes

Handle breaking changes gracefully:

```rust
#[extension_decl]
pub trait VersionedExtension {
    fn get_version() -> u32 { 2 }
    
    fn function_v2(input: NewInputType) -> NewOutputType;
    
    // Deprecated but maintained for compatibility
    #[deprecated]
    fn function_v1(input: OldInputType) -> OldOutputType;
}
```

## Related Components

- [PVQ Extension Core](../pvq-extension-core/) - Core extension functionality
- [PVQ Extension Fungibles](../pvq-extension-fungibles/) - Asset functionality  
- [PVQ Extension Swap](../pvq-extension-swap/) - DEX functionality
- [PVQ Executor](../pvq-executor/) - Execution environment
- [PVQ Program](../pvq-program/) - Program development tools

---

*The PVQ Extension System provides the foundation for modular, secure runtime interaction in PVQ programs.*